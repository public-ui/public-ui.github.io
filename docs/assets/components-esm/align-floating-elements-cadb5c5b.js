/*!
 * KoliBri - The accessible HTML-Standard
 */
import{p as processEnv}from"./reuse-d79ab469.js";const min=Math.min,max=Math.max,round=Math.round,floor=Math.floor,createCoords=e=>({x:e,y:e}),oppositeSideMap={left:"right",right:"left",bottom:"top",top:"bottom"},oppositeAlignmentMap={start:"end",end:"start"};function clamp(e,t,n){return max(e,min(t,n))}function evaluate(e,t){return"function"==typeof e?e(t):e}function getSide(e){return e.split("-")[0]}function getAlignment(e){return e.split("-")[1]}function getOppositeAxis(e){return"x"===e?"y":"x"}function getAxisLength(e){return"y"===e?"height":"width"}function getSideAxis(e){return["top","bottom"].includes(getSide(e))?"y":"x"}function getAlignmentAxis(e){return getOppositeAxis(getSideAxis(e))}function getAlignmentSides(e,t,n){void 0===n&&(n=!1);const o=getAlignment(e),i=getAlignmentAxis(e),l=getAxisLength(i);let r="x"===i?o===(n?"end":"start")?"right":"left":"start"===o?"bottom":"top";return t.reference[l]>t.floating[l]&&(r=getOppositePlacement(r)),[r,getOppositePlacement(r)]}function getExpandedPlacements(e){const t=getOppositePlacement(e);return[getOppositeAlignmentPlacement(e),t,getOppositeAlignmentPlacement(t)]}function getOppositeAlignmentPlacement(e){return e.replace(/start|end/g,(e=>oppositeAlignmentMap[e]))}function getSideList(e,t,n){const o=["left","right"],i=["right","left"],l=["top","bottom"],r=["bottom","top"];switch(e){case"top":case"bottom":return n?t?i:o:t?o:i;case"left":case"right":return t?l:r;default:return[]}}function getOppositeAxisPlacements(e,t,n,o){const i=getAlignment(e);let l=getSideList(getSide(e),"start"===n,o);return i&&(l=l.map((e=>e+"-"+i)),t&&(l=l.concat(l.map(getOppositeAlignmentPlacement)))),l}function getOppositePlacement(e){return e.replace(/left|right|bottom|top/g,(e=>oppositeSideMap[e]))}function expandPaddingObject(e){return{top:0,right:0,bottom:0,left:0,...e}}function getPaddingObject(e){return"number"!=typeof e?expandPaddingObject(e):{top:e,right:e,bottom:e,left:e}}function rectToClientRect(e){return{...e,top:e.y,left:e.x,right:e.x+e.width,bottom:e.y+e.height}}function computeCoordsFromPlacement(e,t,n){let{reference:o,floating:i}=e;const l=getSideAxis(t),r=getAlignmentAxis(t),s=getAxisLength(r),c=getSide(t),a="y"===l,f=o.x+o.width/2-i.width/2,g=o.y+o.height/2-i.height/2,u=o[s]/2-i[s]/2;let d;switch(c){case"top":d={x:f,y:o.y-i.height};break;case"bottom":d={x:f,y:o.y+o.height};break;case"right":d={x:o.x+o.width,y:g};break;case"left":d={x:o.x-i.width,y:g};break;default:d={x:o.x,y:o.y}}switch(getAlignment(t)){case"start":d[r]-=u*(n&&a?-1:1);break;case"end":d[r]+=u*(n&&a?-1:1)}return d}const computePosition$1=async(e,t,n)=>{const{placement:o="bottom",strategy:i="absolute",middleware:l=[],platform:r}=n,s=l.filter(Boolean),c=await(null==r.isRTL?void 0:r.isRTL(t));let a=await r.getElementRects({reference:e,floating:t,strategy:i}),{x:f,y:g}=computeCoordsFromPlacement(a,o,c),u=o,d={},m=0;for(let n=0;n<s.length;n++){const{name:l,fn:p}=s[n],{x:h,y:w,data:y,reset:x}=await p({x:f,y:g,initialPlacement:o,placement:u,strategy:i,middlewareData:d,rects:a,platform:r,elements:{reference:e,floating:t}});f=null!=h?h:f,g=null!=w?w:g,d={...d,[l]:{...d[l],...y}},x&&m<=50&&(m++,"object"==typeof x&&(x.placement&&(u=x.placement),x.rects&&(a=!0===x.rects?await r.getElementRects({reference:e,floating:t,strategy:i}):x.rects),({x:f,y:g}=computeCoordsFromPlacement(a,u,c))),n=-1)}return{x:f,y:g,placement:u,strategy:i,middlewareData:d}};async function detectOverflow(e,t){var n;void 0===t&&(t={});const{x:o,y:i,platform:l,rects:r,elements:s,strategy:c}=e,{boundary:a="clippingAncestors",rootBoundary:f="viewport",elementContext:g="floating",altBoundary:u=!1,padding:d=0}=evaluate(t,e),m=getPaddingObject(d),p=s[u?"floating"===g?"reference":"floating":g],h=rectToClientRect(await l.getClippingRect({element:null==(n=await(null==l.isElement?void 0:l.isElement(p)))||n?p:p.contextElement||await(null==l.getDocumentElement?void 0:l.getDocumentElement(s.floating)),boundary:a,rootBoundary:f,strategy:c})),w="floating"===g?{...r.floating,x:o,y:i}:r.reference,y=await(null==l.getOffsetParent?void 0:l.getOffsetParent(s.floating)),x=await(null==l.isElement?void 0:l.isElement(y))&&await(null==l.getScale?void 0:l.getScale(y))||{x:1,y:1},v=rectToClientRect(l.convertOffsetParentRelativeRectToViewportRelativeRect?await l.convertOffsetParentRelativeRectToViewportRelativeRect({rect:w,offsetParent:y,strategy:c}):w);return{top:(h.top-v.top+m.top)/x.y,bottom:(v.bottom-h.bottom+m.bottom)/x.y,left:(h.left-v.left+m.left)/x.x,right:(v.right-h.right+m.right)/x.x}}const arrow=e=>({name:"arrow",options:e,async fn(t){const{x:n,y:o,placement:i,rects:l,platform:r,elements:s,middlewareData:c}=t,{element:a,padding:f=0}=evaluate(e,t)||{};if(null==a)return{};const g=getPaddingObject(f),u={x:n,y:o},d=getAlignmentAxis(i),m=getAxisLength(d),p=await r.getDimensions(a),h="y"===d,w=h?"top":"left",y=h?"bottom":"right",x=h?"clientHeight":"clientWidth",v=l.reference[m]+l.reference[d]-u[d]-l.floating[m],b=u[d]-l.reference[d],E=await(null==r.getOffsetParent?void 0:r.getOffsetParent(a));let R=E?E[x]:0;R&&await(null==r.isElement?void 0:r.isElement(E))||(R=s.floating[x]||l.floating[m]);const C=v/2-b/2,A=R/2-p[m]/2-1,O=min(g[w],A),S=min(g[y],A),T=O,P=R-p[m]-S,L=R/2-p[m]/2+C,N=clamp(T,L,P),D=!c.arrow&&null!=getAlignment(i)&&L!=N&&l.reference[m]/2-(L<T?O:S)-p[m]/2<0,W=D?L<T?T-L:P-L:0;return{[d]:u[d]-W,data:{[d]:N,centerOffset:L-N+W},reset:D}}}),flip=function(e){return void 0===e&&(e={}),{name:"flip",options:e,async fn(t){var n;const{placement:o,middlewareData:i,rects:l,initialPlacement:r,platform:s,elements:c}=t,{mainAxis:a=!0,crossAxis:f=!0,fallbackPlacements:g,fallbackStrategy:u="bestFit",fallbackAxisSideDirection:d="none",flipAlignment:m=!0,...p}=evaluate(e,t),h=getSide(o),w=getSide(r)===r,y=await(null==s.isRTL?void 0:s.isRTL(c.floating)),x=g||(w||!m?[getOppositePlacement(r)]:getExpandedPlacements(r));g||"none"===d||x.push(...getOppositeAxisPlacements(r,m,d,y));const v=[r,...x],b=await detectOverflow(t,p),E=[];let R=(null==(n=i.flip)?void 0:n.overflows)||[];if(a&&E.push(b[h]),f){const e=getAlignmentSides(o,l,y);E.push(b[e[0]],b[e[1]])}if(R=[...R,{placement:o,overflows:E}],!E.every((e=>e<=0))){var C,A;const e=((null==(C=i.flip)?void 0:C.index)||0)+1,t=v[e];if(t)return{data:{index:e,overflows:R},reset:{placement:t}};let n=null==(A=R.filter((e=>e.overflows[0]<=0)).sort(((e,t)=>e.overflows[1]-t.overflows[1]))[0])?void 0:A.placement;if(!n)switch(u){case"bestFit":{var O;const e=null==(O=R.map((e=>[e.placement,e.overflows.filter((e=>e>0)).reduce(((e,t)=>e+t),0)])).sort(((e,t)=>e[1]-t[1]))[0])?void 0:O[0];e&&(n=e);break}case"initialPlacement":n=r}if(o!==n)return{reset:{placement:n}}}return{}}}};async function convertValueToCoords(e,t){const{placement:n,platform:o,elements:i}=e,l=await(null==o.isRTL?void 0:o.isRTL(i.floating)),r=getSide(n),s=getAlignment(n),c="y"===getSideAxis(n),a=["left","top"].includes(r)?-1:1,f=l&&c?-1:1,g=evaluate(t,e);let{mainAxis:u,crossAxis:d,alignmentAxis:m}="number"==typeof g?{mainAxis:g,crossAxis:0,alignmentAxis:null}:{mainAxis:0,crossAxis:0,alignmentAxis:null,...g};return s&&"number"==typeof m&&(d="end"===s?-1*m:m),c?{x:d*f,y:u*a}:{x:u*a,y:d*f}}const offset=function(e){return void 0===e&&(e=0),{name:"offset",options:e,async fn(t){const{x:n,y:o}=t,i=await convertValueToCoords(t,e);return{x:n+i.x,y:o+i.y,data:i}}}},shift=function(e){return void 0===e&&(e={}),{name:"shift",options:e,async fn(t){const{x:n,y:o,placement:i}=t,{mainAxis:l=!0,crossAxis:r=!1,limiter:s={fn:e=>{let{x:t,y:n}=e;return{x:t,y:n}}},...c}=evaluate(e,t),a={x:n,y:o},f=await detectOverflow(t,c),g=getSideAxis(getSide(i)),u=getOppositeAxis(g);let d=a[u],m=a[g];if(l){const e="y"===u?"bottom":"right";d=clamp(d+f["y"===u?"top":"left"],d,d-f[e])}if(r){const e="y"===g?"bottom":"right";m=clamp(m+f["y"===g?"top":"left"],m,m-f[e])}const p=s.fn({...t,[u]:d,[g]:m});return{...p,data:{x:p.x-n,y:p.y-o}}}}};function getNodeName(e){return isNode(e)?(e.nodeName||"").toLowerCase():"#document"}function getWindow(e){var t;return(null==e||null==(t=e.ownerDocument)?void 0:t.defaultView)||window}function getDocumentElement(e){var t;return null==(t=(isNode(e)?e.ownerDocument:e.document)||window.document)?void 0:t.documentElement}function isNode(e){return e instanceof Node||e instanceof getWindow(e).Node}function isElement(e){return e instanceof Element||e instanceof getWindow(e).Element}function isHTMLElement(e){return e instanceof HTMLElement||e instanceof getWindow(e).HTMLElement}function isShadowRoot(e){return"undefined"!=typeof ShadowRoot&&(e instanceof ShadowRoot||e instanceof getWindow(e).ShadowRoot)}function isOverflowElement(e){const{overflow:t,overflowX:n,overflowY:o,display:i}=getComputedStyle(e);return/auto|scroll|overlay|hidden|clip/.test(t+o+n)&&!["inline","contents"].includes(i)}function isTableElement(e){return["table","td","th"].includes(getNodeName(e))}function isContainingBlock(e){const t=isWebKit(),n=getComputedStyle(e);return"none"!==n.transform||"none"!==n.perspective||!!n.containerType&&"normal"!==n.containerType||!t&&!!n.backdropFilter&&"none"!==n.backdropFilter||!t&&!!n.filter&&"none"!==n.filter||["transform","perspective","filter"].some((e=>(n.willChange||"").includes(e)))||["paint","layout","strict","content"].some((e=>(n.contain||"").includes(e)))}function getContainingBlock(e){let t=getParentNode(e);for(;isHTMLElement(t)&&!isLastTraversableNode(t);){if(isContainingBlock(t))return t;t=getParentNode(t)}return null}function isWebKit(){return!("undefined"==typeof CSS||!CSS.supports)&&CSS.supports("-webkit-backdrop-filter","none")}function isLastTraversableNode(e){return["html","body","#document"].includes(getNodeName(e))}function getComputedStyle(e){return getWindow(e).getComputedStyle(e)}function getNodeScroll(e){return isElement(e)?{scrollLeft:e.scrollLeft,scrollTop:e.scrollTop}:{scrollLeft:e.pageXOffset,scrollTop:e.pageYOffset}}function getParentNode(e){if("html"===getNodeName(e))return e;const t=e.assignedSlot||e.parentNode||isShadowRoot(e)&&e.host||getDocumentElement(e);return isShadowRoot(t)?t.host:t}function getNearestOverflowAncestor(e){const t=getParentNode(e);return isLastTraversableNode(t)?e.ownerDocument?e.ownerDocument.body:e.body:isHTMLElement(t)&&isOverflowElement(t)?t:getNearestOverflowAncestor(t)}function getOverflowAncestors(e,t,n){var o;void 0===t&&(t=[]),void 0===n&&(n=!0);const i=getNearestOverflowAncestor(e),l=i===(null==(o=e.ownerDocument)?void 0:o.body),r=getWindow(i);return l?t.concat(r,r.visualViewport||[],isOverflowElement(i)?i:[],r.frameElement&&n?getOverflowAncestors(r.frameElement):[]):t.concat(i,getOverflowAncestors(i))}function getCssDimensions(e){const t=getComputedStyle(e);let n=parseFloat(t.width)||0,o=parseFloat(t.height)||0;const i=isHTMLElement(e),l=i?e.offsetWidth:n,r=i?e.offsetHeight:o,s=round(n)!==l||round(o)!==r;return s&&(n=l,o=r),{width:n,height:o,$:s}}function unwrapElement(e){return isElement(e)?e:e.contextElement}function getScale(e){const t=unwrapElement(e);if(!isHTMLElement(t))return createCoords(1);const n=t.getBoundingClientRect(),{width:o,height:i,$:l}=getCssDimensions(t);let r=(l?round(n.width):n.width)/o,s=(l?round(n.height):n.height)/i;return r&&Number.isFinite(r)||(r=1),s&&Number.isFinite(s)||(s=1),{x:r,y:s}}const noOffsets=createCoords(0);function getVisualOffsets(e){const t=getWindow(e);return isWebKit()&&t.visualViewport?{x:t.visualViewport.offsetLeft,y:t.visualViewport.offsetTop}:noOffsets}function shouldAddVisualOffsets(e,t,n){return void 0===t&&(t=!1),!(!n||t&&n!==getWindow(e))&&t}function getBoundingClientRect(e,t,n,o){void 0===t&&(t=!1),void 0===n&&(n=!1);const i=e.getBoundingClientRect(),l=unwrapElement(e);let r=createCoords(1);t&&(o?isElement(o)&&(r=getScale(o)):r=getScale(e));const s=shouldAddVisualOffsets(l,n,o)?getVisualOffsets(l):createCoords(0);let c=(i.left+s.x)/r.x,a=(i.top+s.y)/r.y,f=i.width/r.x,g=i.height/r.y;if(l){const e=getWindow(l),t=o&&isElement(o)?getWindow(o):o;let n=e.frameElement;for(;n&&o&&t!==e;){const e=getScale(n),t=n.getBoundingClientRect(),o=getComputedStyle(n),i=t.left+(n.clientLeft+parseFloat(o.paddingLeft))*e.x,l=t.top+(n.clientTop+parseFloat(o.paddingTop))*e.y;c*=e.x,a*=e.y,f*=e.x,g*=e.y,c+=i,a+=l,n=getWindow(n).frameElement}}return rectToClientRect({width:f,height:g,x:c,y:a})}function convertOffsetParentRelativeRectToViewportRelativeRect(e){let{rect:t,offsetParent:n,strategy:o}=e;const i=isHTMLElement(n),l=getDocumentElement(n);if(n===l)return t;let r={scrollLeft:0,scrollTop:0},s=createCoords(1);const c=createCoords(0);if((i||!i&&"fixed"!==o)&&(("body"!==getNodeName(n)||isOverflowElement(l))&&(r=getNodeScroll(n)),isHTMLElement(n))){const e=getBoundingClientRect(n);s=getScale(n),c.x=e.x+n.clientLeft,c.y=e.y+n.clientTop}return{width:t.width*s.x,height:t.height*s.y,x:t.x*s.x-r.scrollLeft*s.x+c.x,y:t.y*s.y-r.scrollTop*s.y+c.y}}function getClientRects(e){return Array.from(e.getClientRects())}function getWindowScrollBarX(e){return getBoundingClientRect(getDocumentElement(e)).left+getNodeScroll(e).scrollLeft}function getDocumentRect(e){const t=getDocumentElement(e),n=getNodeScroll(e),o=e.ownerDocument.body,i=max(t.scrollWidth,t.clientWidth,o.scrollWidth,o.clientWidth),l=max(t.scrollHeight,t.clientHeight,o.scrollHeight,o.clientHeight);let r=-n.scrollLeft+getWindowScrollBarX(e);const s=-n.scrollTop;return"rtl"===getComputedStyle(o).direction&&(r+=max(t.clientWidth,o.clientWidth)-i),{width:i,height:l,x:r,y:s}}function getViewportRect(e,t){const n=getWindow(e),o=getDocumentElement(e),i=n.visualViewport;let l=o.clientWidth,r=o.clientHeight,s=0,c=0;if(i){l=i.width,r=i.height;const e=isWebKit();(!e||e&&"fixed"===t)&&(s=i.offsetLeft,c=i.offsetTop)}return{width:l,height:r,x:s,y:c}}function getInnerBoundingClientRect(e,t){const n=getBoundingClientRect(e,!0,"fixed"===t),o=n.top+e.clientTop,i=n.left+e.clientLeft,l=isHTMLElement(e)?getScale(e):createCoords(1);return{width:e.clientWidth*l.x,height:e.clientHeight*l.y,x:i*l.x,y:o*l.y}}function getClientRectFromClippingAncestor(e,t,n){let o;if("viewport"===t)o=getViewportRect(e,n);else if("document"===t)o=getDocumentRect(getDocumentElement(e));else if(isElement(t))o=getInnerBoundingClientRect(t,n);else{const n=getVisualOffsets(e);o={...t,x:t.x-n.x,y:t.y-n.y}}return rectToClientRect(o)}function hasFixedPositionAncestor(e,t){const n=getParentNode(e);return!(n===t||!isElement(n)||isLastTraversableNode(n))&&("fixed"===getComputedStyle(n).position||hasFixedPositionAncestor(n,t))}function getClippingElementAncestors(e,t){const n=t.get(e);if(n)return n;let o=getOverflowAncestors(e,[],!1).filter((e=>isElement(e)&&"body"!==getNodeName(e))),i=null;const l="fixed"===getComputedStyle(e).position;let r=l?getParentNode(e):e;for(;isElement(r)&&!isLastTraversableNode(r);){const t=getComputedStyle(r),n=isContainingBlock(r);n||"fixed"!==t.position||(i=null);(l?!n&&!i:!n&&"static"===t.position&&!!i&&["absolute","fixed"].includes(i.position)||isOverflowElement(r)&&!n&&hasFixedPositionAncestor(e,r))?o=o.filter((e=>e!==r)):i=t,r=getParentNode(r)}return t.set(e,o),o}function getClippingRect(e){let{element:t,boundary:n,rootBoundary:o,strategy:i}=e;const l=[..."clippingAncestors"===n?getClippingElementAncestors(t,this._c):[].concat(n),o],r=l[0],s=l.reduce(((e,n)=>{const o=getClientRectFromClippingAncestor(t,n,i);return e.top=max(o.top,e.top),e.right=min(o.right,e.right),e.bottom=min(o.bottom,e.bottom),e.left=max(o.left,e.left),e}),getClientRectFromClippingAncestor(t,r,i));return{width:s.right-s.left,height:s.bottom-s.top,x:s.left,y:s.top}}function getDimensions(e){return getCssDimensions(e)}function getRectRelativeToOffsetParent(e,t,n){const o=isHTMLElement(t),i=getDocumentElement(t),l="fixed"===n,r=getBoundingClientRect(e,!0,l,t);let s={scrollLeft:0,scrollTop:0};const c=createCoords(0);if(o||!o&&!l)if(("body"!==getNodeName(t)||isOverflowElement(i))&&(s=getNodeScroll(t)),o){const e=getBoundingClientRect(t,!0,l,t);c.x=e.x+t.clientLeft,c.y=e.y+t.clientTop}else i&&(c.x=getWindowScrollBarX(i));return{x:r.left+s.scrollLeft-c.x,y:r.top+s.scrollTop-c.y,width:r.width,height:r.height}}function getTrueOffsetParent(e,t){return isHTMLElement(e)&&"fixed"!==getComputedStyle(e).position?t?t(e):e.offsetParent:null}function getOffsetParent(e,t){const n=getWindow(e);if(!isHTMLElement(e))return n;let o=getTrueOffsetParent(e,t);for(;o&&isTableElement(o)&&"static"===getComputedStyle(o).position;)o=getTrueOffsetParent(o,t);return o&&("html"===getNodeName(o)||"body"===getNodeName(o)&&"static"===getComputedStyle(o).position&&!isContainingBlock(o))?n:o||getContainingBlock(e)||n}const getElementRects=async function(e){let{reference:t,floating:n,strategy:o}=e;const i=this.getOffsetParent||getOffsetParent,l=this.getDimensions;return{reference:getRectRelativeToOffsetParent(t,await i(n),o),floating:{x:0,y:0,...await l(n)}}};function isRTL(e){return"rtl"===getComputedStyle(e).direction}const platform={convertOffsetParentRelativeRectToViewportRelativeRect:convertOffsetParentRelativeRectToViewportRelativeRect,getDocumentElement:getDocumentElement,getClippingRect:getClippingRect,getOffsetParent:getOffsetParent,getElementRects:getElementRects,getClientRects:getClientRects,getDimensions:getDimensions,getScale:getScale,isElement:isElement,isRTL:isRTL};function observeMove(e,t){let n,o=null;const i=getDocumentElement(e);function l(){clearTimeout(n),o&&o.disconnect(),o=null}return function r(s,c){void 0===s&&(s=!1),void 0===c&&(c=1),l();const{left:a,top:f,width:g,height:u}=e.getBoundingClientRect();if(s||t(),!g||!u)return;const d={rootMargin:-floor(f)+"px "+-floor(i.clientWidth-(a+g))+"px "+-floor(i.clientHeight-(f+u))+"px "+-floor(a)+"px",threshold:max(0,min(1,c))||1};let m=!0;function p(e){const t=e[0].intersectionRatio;if(t!==c){if(!m)return r();t?r(!1,t):n=setTimeout((()=>{r(!1,1e-7)}),100)}m=!1}try{o=new IntersectionObserver(p,{...d,root:i.ownerDocument})}catch(e){o=new IntersectionObserver(p,d)}o.observe(e)}(!0),l}function autoUpdate(e,t,n,o){void 0===o&&(o={});const{ancestorScroll:i=!0,ancestorResize:l=!0,elementResize:r="function"==typeof ResizeObserver,layoutShift:s="function"==typeof IntersectionObserver,animationFrame:c=!1}=o,a=unwrapElement(e),f=i||l?[...a?getOverflowAncestors(a):[],...getOverflowAncestors(t)]:[];f.forEach((e=>{i&&e.addEventListener("scroll",n,{passive:!0}),l&&e.addEventListener("resize",n)}));const g=a&&s?observeMove(a,n):null;let u,d=-1,m=null;r&&(m=new ResizeObserver((e=>{let[o]=e;o&&o.target===a&&m&&(m.unobserve(t),cancelAnimationFrame(d),d=requestAnimationFrame((()=>{m&&m.observe(t)}))),n()})),a&&!c&&m.observe(a),m.observe(t));let p=c?getBoundingClientRect(e):null;return c&&function t(){const o=getBoundingClientRect(e);!p||o.x===p.x&&o.y===p.y&&o.width===p.width&&o.height===p.height||n();p=o,u=requestAnimationFrame(t)}(),n(),()=>{f.forEach((e=>{i&&e.removeEventListener("scroll",n),l&&e.removeEventListener("resize",n)})),g&&g(),m&&m.disconnect(),m=null,c&&cancelAnimationFrame(u)}}const computePosition=(e,t,n)=>{const o=new Map,i={platform:platform,...n},l={...i.platform,_c:o};return computePosition$1(e,t,{...i,platform:l})},alignFloatingElements=async({floatingElement:e,referenceElement:t,arrowElement:n,align:o="top"})=>{var i,l,r;if("test"!==processEnv){const s=[offset(null!==(i=null==n?void 0:n.offsetHeight)&&void 0!==i?i:10),flip(),shift()];n&&s.push(arrow({element:n}));const{x:c,y:a,middlewareData:f,placement:g}=await computePosition(t,e,{placement:o,middleware:s});Object.assign(e.style,{left:`${c}px`,top:`${a}px`,visibility:"visible"}),n&&((null===(l=f.arrow)||void 0===l?void 0:l.x)?Object.assign(n.style,{left:`${f.arrow.x}px`,top:"bottom"===g?-n.offsetHeight/2+"px":"",bottom:"top"===g?-n.offsetHeight/2+"px":""}):(null===(r=f.arrow)||void 0===r?void 0:r.y)&&Object.assign(n.style,{left:"right"===g?-n.offsetWidth/2+"px":"",right:"left"===g?-n.offsetWidth/2+"px":"",top:`${f.arrow.y}px`}))}};export{alignFloatingElements as a,autoUpdate as b};