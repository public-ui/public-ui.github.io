{"file":"label-5f92bb62.js","mappings":";;;;;;AAYA,MAAM,cAAc,GAAG,qBAAqB,CAAC;AAK7C,MAAM,YAAY,GAAG,OAAO,CAAC;AAO7B,SAAS,kBAAkB,CAAC,GAAW;;IACtC,OAAO,OAAO,GAAG,KAAK,QAAQ,GAAG,CAAA,MAAA,GAAG,CAAC,KAAK,CAAC,cAAc,CAAC,0CAAE,MAAM,KAAI,CAAC,GAAG,CAAC,CAAC;AAC7E,CAAC;SAQe,sBAAsB,CAAC,GAAW,EAAE,GAAG,GAAG,CAAC;IAC1D,OAAO,kBAAkB,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC;AACvC,CAAC;SAOe,mBAAmB,CAAC,GAAW;IAC9C,OAAO,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC/B,CAAC;AAqCD,SAAS,oBAAoB,CAAC,OAA2B;;IACxD,OAAO;QACN,KAAK,EAAE;YACN,UAAU,EAAE,CAAC,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG;;gBACxC,IAAI,QAAO,MAAA,OAAO,CAAC,KAAK,0CAAE,UAAU,CAAA,KAAK,UAAU,EAAE;oBACpD,MAAA,OAAO,CAAC,KAAK,0CAAE,UAAU,CAAC,KAAK,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,CAAC,CAAC;iBACxD;gBACD,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,sBAAsB,CAAC,KAAK,EAAE,CAAC,CAAC,KAAK,KAAK,IAAI,mBAAmB,CAAC,KAAK,CAAC,KAAK,KAAK,EAAE;oBACpH,QAAQ,CAAC,0BAA0B,KAAK,qFAAqF,CAAC,CAAC;iBAC/H;gBACD,IAAI,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,EAAE;oBACnD,QAAQ,CAAC,6DAA6D,CAAC,CAAC;iBACxE;aACD;YACD,WAAW,EAAE,MAAA,OAAO,CAAC,KAAK,0CAAE,WAAW;SACvC;KACD,CAAC;AACH,CAAC;AAED,MAAM,YAAY,GAAG,IAAI,GAAG,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;MAC5B,aAAa,GAAG,CAAC,SAAoC,EAAE,KAAqB,EAAE,UAA8B,EAAE;IAC1H,cAAc,CAAC,SAAS,EAAE,QAAQ,EAAE,CAAC,KAAK,KAAK,OAAO,KAAK,KAAK,QAAQ,EAAE,YAAY,EAAE,KAAK,EAAE,oBAAoB,CAAC,OAAO,CAAC,CAAC,CAAC;AAC/H,EAAE;MAMW,2BAA2B,GAAG;;;;","names":[],"sources":["src/types/props/label.ts"],"sourcesContent":["import type { Generic } from 'adopted-style-sheets';\n\nimport { a11yHint, uiUxHint } from '../../utils/a11y.tipps';\nimport { WatchStringOptions, watchValidator } from '../../utils/prop.validators';\n\n/* types */\n\n/**\n * This is a regular expression that matches all readable characters.\n *\n * Interesting: https://stackoverflow.com/questions/150033/regular-expression-to-match-non-english-characters\n */\nconst READABLE_CHARS = /[a-zA-Z0-9äöüÄÖÜß]/g;\n\n/**\n * This is a regular expression that matches only numbers.\n */\nconst ONLY_NUMBERS = /^\\d+$/;\n\n/**\n * This function counts the number of readable characters in a string.\n * @param str The string to count.\n * @returns The number of readable characters in the string.\n */\nfunction countReadableChars(str: string): number {\n\treturn typeof str === 'string' ? str.match(READABLE_CHARS)?.length || 0 : 0;\n}\n\n/**\n * This function checks if a string has at least a certain number of readable characters.\n * @param str The string to check.\n * @param min The minimum number of readable characters.\n * @returns True if the string has at least the minimum number of readable characters, false otherwise.\n */\nexport function hasEnoughReadableChars(str: string, min = 1): boolean {\n\treturn countReadableChars(str) >= min;\n}\n\n/**\n * This function checks if a string contains only numbers.\n * @param str The string to check.\n * @returns True if the string contains only numbers, false otherwise.\n */\nexport function containsOnlyNumbers(str: string): boolean {\n\treturn ONLY_NUMBERS.test(str);\n}\n\n/**\n * Defines the type of the label property.\n */\nexport type LabelPropType = string;\n\n/**\n * Defines the visible or semantic label of the component (e.g. aria-label, label, headline, caption, summary, etc.). Set to `false` to enable the expert slot.\n */\nexport type LabelWithExpertSlotPropType = LabelPropType | '';\n\n/**\n * The label property is used to label different elements:\n * - abbr -> title text\n * - button -> label text\n * - heading -> headline text\n * - input, select and textarea -> label text\n * - summary -> summary text\n * - quote, table -> caption text\n * - version -> version text\n * - etc.\n *\n * The label is often a mandatory attribute. If the value of the label is false,\n * the expert-slot will be used. Otherwise, the value of the label must be a string\n * and the expert-slot will be ignored.\n */\nexport type PropLabel = {\n\tlabel: LabelPropType;\n};\nexport type PropLabelWithExpertSlot = {\n\tlabel: LabelWithExpertSlotPropType;\n};\n\nexport type LabelProp = Generic.Element.Members<proplabel , unknown>;\n// type LabelWithExpertSlotProp = Generic.Element.Members<proplabelwithexpertslot , unknown>;\n\nfunction getValidationOptions(options: WatchStringOptions): WatchStringOptions {\n\treturn {\n\t\thooks: {\n\t\t\tafterPatch: (value, state, component, key) => {\n\t\t\t\tif (typeof options.hooks?.afterPatch === 'function') {\n\t\t\t\t\toptions.hooks?.afterPatch(value, state, component, key);\n\t\t\t\t}\n\t\t\t\tif (typeof value === 'string' && hasEnoughReadableChars(value, 3) === false && containsOnlyNumbers(value) === false) {\n\t\t\t\t\ta11yHint(`The heading or label (\"${value}\") is not accessible. A label should consist of at least three readable characters.`);\n\t\t\t\t}\n\t\t\t\tif (typeof value === 'string' && value.length > 80) {\n\t\t\t\t\tuiUxHint(`A heading or label should not be longer than 80 characters.`);\n\t\t\t\t}\n\t\t\t},\n\t\t\tbeforePatch: options.hooks?.beforePatch,\n\t\t},\n\t};\n}\n\nconst LABEL_VALUES = new Set(['string']);\nexport const validateLabel = (component: Generic.Element.Component, value?: LabelPropType, options: WatchStringOptions = {}): void => {\n\twatchValidator(component, '_label', (value) => typeof value === 'string', LABEL_VALUES, value, getValidationOptions(options));\n};\n\n/**\n * This method name helps to differentiate between the label\n * and the label with expert slot usage.\n */\nexport const validateLabelWithExpertSlot = validateLabel;\n"],"version":3}</proplabelwithexpertslot></proplabel>