{"version":3,"names":["validateHasCounter","component","value","watchBoolean","InputPasswordController","InputIconController","constructor","name","host","super","this","handleHiddenLabelAndRequired","state","_hideLabel","_required","devHint","hideLabel","validateAutoComplete","watchValidator","Set","validateHideLabel","hooks","afterPatch","validateMaxLength","watchNumber","min","validatePattern","watchString","validatePlaceholder","validateReadOnly","validateRequired","validateSize","validateValue","setFormAssociatedValue","_value","componentWillLoad","_autoComplete","_hasCounter","_maxLength","_pattern","_placeholder","_readOnly","_size","onBlur","event","Object","assign","placeholderCache","undefined","onFocus"],"sources":["src/types/props/has-counter.ts","src/components/input-password/controller.ts"],"sourcesContent":["import { Generic } from '@a11y-ui/core';\r\n\r\nimport { watchBoolean } from '../../utils/prop.validators';\r\n\r\n/* types */\r\n/** de\r\n * Zeigt die Zeichenanzahlanzeige am unteren Rand des EIngabefeldes.\r\n */\r\n/** en\r\n * Shows the the character count on the lower border of the input.\r\n */\r\nexport type PropHasCounter = {\r\n\thasCounter: boolean;\r\n};\r\n\r\n/* validator */\r\nexport const validateHasCounter = (component: Generic.Element.Component, value?: boolean): void => {\r\n\twatchBoolean(component, '_hasCounter', value);\r\n};\r\n","import { Generic } from '@a11y-ui/core';\r\n\r\nimport { InputTypeOnOff } from '../../types/input/types';\r\nimport { validateHasCounter } from '../../types/props/has-counter';\r\nimport { devHint } from '../../utils/a11y.tipps';\r\nimport { watchBoolean, watchNumber, watchString, watchValidator } from '../../utils/prop.validators';\r\nimport { InputIconController } from '../@deprecated/input/controller-icon';\r\nimport { Props, Watches } from './types';\r\n\r\nexport class InputPasswordController extends InputIconController implements Watches {\r\n\tprotected readonly component: Generic.Element.Component & Props;\r\n\tprivate placeholderCache?: string;\r\n\r\n\tpublic constructor(component: Generic.Element.Component & Props, name: string, host?: HTMLElement) {\r\n\t\tsuper(component, name, host);\r\n\t\tthis.component = component;\r\n\t}\r\n\r\n\tprivate handleHiddenLabelAndRequired = (): void => {\r\n\t\tif (this.component.state._hideLabel === true && this.component.state._required === true) {\r\n\t\t\tdevHint(`[KolInput*] Wenn man das Label ausblendet, dann kann der sehende Nutzer:in nicht mehr erkennen, ob die Eingabe erforderlich ist.`);\r\n\t\t\tthis.hideLabel = false;\r\n\t\t} else {\r\n\t\t\tthis.hideLabel = this.component.state._hideLabel === true;\r\n\t\t}\r\n\t};\r\n\r\n\tpublic validateAutoComplete(value?: InputTypeOnOff): void {\r\n\t\twatchValidator(\r\n\t\t\tthis.component,\r\n\t\t\t'_autoComplete',\r\n\t\t\t(value): boolean => typeof value === 'string' && (value === 'on' || value === 'off'),\r\n\t\t\tnew Set(['on | off']),\r\n\t\t\tvalue\r\n\t\t);\r\n\t}\r\n\r\n\tpublic validateHasCounter(value?: boolean): void {\r\n\t\tvalidateHasCounter(this.component, value);\r\n\t}\r\n\r\n\tpublic validateHideLabel(value?: boolean): void {\r\n\t\twatchBoolean(this.component, '_hideLabel', value, {\r\n\t\t\thooks: {\r\n\t\t\t\tafterPatch: this.handleHiddenLabelAndRequired,\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\tpublic validateMaxLength(value?: number): void {\r\n\t\twatchNumber(this.component, '_maxLength', value, {\r\n\t\t\tmin: 0,\r\n\t\t});\r\n\t}\r\n\r\n\tpublic validatePattern(value?: string): void {\r\n\t\twatchString(this.component, '_pattern', value);\r\n\t}\r\n\r\n\tpublic validatePlaceholder(value?: string): void {\r\n\t\twatchString(this.component, '_placeholder', value);\r\n\t}\r\n\r\n\tpublic validateReadOnly(value?: boolean): void {\r\n\t\twatchBoolean(this.component, '_readOnly', value);\r\n\t}\r\n\r\n\tpublic validateRequired(value?: boolean): void {\r\n\t\twatchBoolean(this.component, '_required', value, {\r\n\t\t\thooks: {\r\n\t\t\t\tafterPatch: this.handleHiddenLabelAndRequired,\r\n\t\t\t},\r\n\t\t});\r\n\t}\r\n\r\n\tpublic validateSize(value?: number): void {\r\n\t\twatchNumber(this.component, '_size', value, {\r\n\t\t\tmin: 1,\r\n\t\t});\r\n\t}\r\n\r\n\tpublic validateValue(value?: string): void {\r\n\t\twatchString(this.component, '_value', value);\r\n\t\tthis.setFormAssociatedValue(this.component.state._value as string);\r\n\t}\r\n\r\n\tpublic componentWillLoad(): void {\r\n\t\tsuper.componentWillLoad();\r\n\t\tthis.validateAutoComplete(this.component._autoComplete);\r\n\t\tthis.validateHasCounter(this.component._hasCounter);\r\n\t\tthis.validateMaxLength(this.component._maxLength);\r\n\t\tthis.validatePattern(this.component._pattern);\r\n\t\tthis.validatePlaceholder(this.component._placeholder);\r\n\t\tthis.validateReadOnly(this.component._readOnly);\r\n\t\tthis.validateRequired(this.component._required);\r\n\t\tthis.validateSize(this.component._size);\r\n\t\tthis.validateValue(this.component._value);\r\n\t}\r\n\r\n\tprotected onBlur(event: Event): void {\r\n\t\t/**\r\n\t\t * Beim Screenreader NVDA wird der Placeholder mit\r\n\t\t * vorgelesen. Somit kann es vorkommen, dass das\r\n\t\t * Label und der Placeholder vorgelesen werden.\r\n\t\t *\r\n\t\t * Aufgrund dessen, dass das Label immer vorgelesen\r\n\t\t * werden muss, kann das zusätzliche Vorlesen des\r\n\t\t * Placeholders störend sein.\r\n\t\t *\r\n\t\t * Damit beim Fokussieren das \"doppelte\" vorlesen\r\n\t\t * vermieden werden kann, wird der Placeholder für\r\n\t\t * den fokussierten Feldstatus entfernt.\r\n\t\t *\r\n\t\t * Hinweis: Für alle Nutzenden müssen die all dar-\r\n\t\t *          gestellten Inhalte, also auch der Place-\r\n\t\t *          holder, gleichermaßen zugänglich sein.\r\n\t\t *          Das oben beschriebene Handling erfüllt\r\n\t\t *          diese Anforderung nicht.\r\n\t\t */\r\n\t\tthis.component.state = {\r\n\t\t\t...this.component.state,\r\n\t\t\t_placeholder: this.placeholderCache,\r\n\t\t};\r\n\t\tthis.placeholderCache = undefined;\r\n\t\tsuper.onBlur(event);\r\n\t}\r\n\r\n\tprotected onFocus(event: Event): void {\r\n\t\tthis.placeholderCache = this.component.state._placeholder as string;\r\n\t\tthis.component.state = {\r\n\t\t\t...this.component.state,\r\n\t\t\t_placeholder: undefined,\r\n\t\t};\r\n\t\tsuper.onFocus(event);\r\n\t}\r\n}\r\n"],"mappings":";;;4KAgBaA,EAAqB,CAACC,EAAsCC,KACxEC,EAAaF,EAAW,cAAeC,EAAM,E,MCRjCE,UAAgCC,EAI5CC,YAAmBL,EAA8CM,EAAcC,GAC9EC,MAAMR,EAAWM,EAAMC,GAIhBE,KAAAC,6BAA+B,KACtC,GAAID,KAAKT,UAAUW,MAAMC,aAAe,MAAQH,KAAKT,UAAUW,MAAME,YAAc,KAAM,CACxFC,EAAQ,oIACRL,KAAKM,UAAY,K,KACX,CACNN,KAAKM,UAAYN,KAAKT,UAAUW,MAAMC,aAAe,I,GARtDH,KAAKT,UAAYA,C,CAYXgB,qBAAqBf,GAC3BgB,EACCR,KAAKT,UACL,iBACCC,UAA0BA,IAAU,WAAaA,IAAU,MAAQA,IAAU,QAC9E,IAAIiB,IAAI,CAAC,aACTjB,E,CAIKF,mBAAmBE,GACzBF,EAAmBU,KAAKT,UAAWC,E,CAG7BkB,kBAAkBlB,GACxBC,EAAaO,KAAKT,UAAW,aAAcC,EAAO,CACjDmB,MAAO,CACNC,WAAYZ,KAAKC,+B,CAKbY,kBAAkBrB,GACxBsB,EAAYd,KAAKT,UAAW,aAAcC,EAAO,CAChDuB,IAAK,G,CAIAC,gBAAgBxB,GACtByB,EAAYjB,KAAKT,UAAW,WAAYC,E,CAGlC0B,oBAAoB1B,GAC1ByB,EAAYjB,KAAKT,UAAW,eAAgBC,E,CAGtC2B,iBAAiB3B,GACvBC,EAAaO,KAAKT,UAAW,YAAaC,E,CAGpC4B,iBAAiB5B,GACvBC,EAAaO,KAAKT,UAAW,YAAaC,EAAO,CAChDmB,MAAO,CACNC,WAAYZ,KAAKC,+B,CAKboB,aAAa7B,GACnBsB,EAAYd,KAAKT,UAAW,QAASC,EAAO,CAC3CuB,IAAK,G,CAIAO,cAAc9B,GACpByB,EAAYjB,KAAKT,UAAW,SAAUC,GACtCQ,KAAKuB,uBAAuBvB,KAAKT,UAAUW,MAAMsB,O,CAG3CC,oBACN1B,MAAM0B,oBACNzB,KAAKO,qBAAqBP,KAAKT,UAAUmC,eACzC1B,KAAKV,mBAAmBU,KAAKT,UAAUoC,aACvC3B,KAAKa,kBAAkBb,KAAKT,UAAUqC,YACtC5B,KAAKgB,gBAAgBhB,KAAKT,UAAUsC,UACpC7B,KAAKkB,oBAAoBlB,KAAKT,UAAUuC,cACxC9B,KAAKmB,iBAAiBnB,KAAKT,UAAUwC,WACrC/B,KAAKoB,iBAAiBpB,KAAKT,UAAUa,WACrCJ,KAAKqB,aAAarB,KAAKT,UAAUyC,OACjChC,KAAKsB,cAActB,KAAKT,UAAUiC,O,CAGzBS,OAAOC,GAoBhBlC,KAAKT,UAAUW,MAAKiC,OAAAC,OAAAD,OAAAC,OAAA,GAChBpC,KAAKT,UAAUW,OAAK,CACvB4B,aAAc9B,KAAKqC,mBAEpBrC,KAAKqC,iBAAmBC,UACxBvC,MAAMkC,OAAOC,E,CAGJK,QAAQL,GACjBlC,KAAKqC,iBAAmBrC,KAAKT,UAAUW,MAAM4B,aAC7C9B,KAAKT,UAAUW,MAAKiC,OAAAC,OAAAD,OAAAC,OAAA,GAChBpC,KAAKT,UAAUW,OAAK,CACvB4B,aAAcQ,YAEfvC,MAAMwC,QAAQL,E"}