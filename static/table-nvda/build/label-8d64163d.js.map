{"version":3,"names":["READABLE_CHARS","ONLY_NUMBERS","countReadableChars","str","_a","match","length","hasEnoughReadableChars","min","containsOnlyNumbers","test","getValidationOptions","options","hooks","afterPatch","value","state","component","key","_b","a11yHint","uiUxHint","beforePatch","LABEL_VALUES","Set","validateLabel","watchValidator","LABEL_WITH_EXPERT_SLOT_VALUES","validateLabelWithExpertSlot"],"sources":["src/types/props/label.ts"],"sourcesContent":["import { Generic } from '@a11y-ui/core';\r\n\r\nimport { a11yHint, uiUxHint } from '../../utils/a11y.tipps';\r\nimport { WatchStringOptions, watchValidator } from '../../utils/prop.validators';\r\n\r\n/* types */\r\n\r\n/**\r\n * This is a regular expression that matches all readable characters.\r\n *\r\n * Interesting: https://stackoverflow.com/questions/150033/regular-expression-to-match-non-english-characters\r\n */\r\nconst READABLE_CHARS = /[a-zA-Z0-9äöüÄÖÜß]/g;\r\n\r\n/**\r\n * This is a regular expression that matches only numbers.\r\n */\r\nconst ONLY_NUMBERS = /^\\d+$/;\r\n\r\n/**\r\n * This function counts the number of readable characters in a string.\r\n * @param str The string to count.\r\n * @returns The number of readable characters in the string.\r\n */\r\nfunction countReadableChars(str: string): number {\r\n\treturn typeof str === 'string' ? str.match(READABLE_CHARS)?.length || 0 : 0;\r\n}\r\n\r\n/**\r\n * This function checks if a string has at least a certain number of readable characters.\r\n * @param str The string to check.\r\n * @param min The minimum number of readable characters.\r\n * @returns True if the string has at least the minimum number of readable characters, false otherwise.\r\n */\r\nexport function hasEnoughReadableChars(str: string, min = 1): boolean {\r\n\treturn countReadableChars(str) >= min;\r\n}\r\n\r\n/**\r\n * This function checks if a string contains only numbers.\r\n * @param str The string to check.\r\n * @returns True if the string contains only numbers, false otherwise.\r\n */\r\nexport function containsOnlyNumbers(str: string): boolean {\r\n\treturn ONLY_NUMBERS.test(str);\r\n}\r\n\r\n/**\r\n * Defines the type of the label property.\r\n */\r\nexport type LabelPropType = string;\r\n\r\n/**\r\n * Defines the type of the label with expert-slot toggle property.\r\n */\r\nexport type LabelWithExpertSlotPropType = LabelPropType | false;\r\n\r\n/**\r\n * The label property is used to label different elements:\r\n * - abbr -> title text\r\n * - button -> label text\r\n * - heading -> headline text\r\n * - input, select and textarea -> label text\r\n * - summary -> summary text\r\n * - quote, table -> caption text\r\n * - version -> version text\r\n * - etc.\r\n *\r\n * The label is often a mandatory attribute. If the value of the label is false,\r\n * the expert-slot will be used. Otherwise, the value of the label must be a string\r\n * and the expert-slot will be ignored.\r\n */\r\nexport type PropLabel = {\r\n\tlabel: LabelPropType;\r\n};\r\nexport type PropLabelWithExpertSlot = {\r\n\tlabel: LabelWithExpertSlotPropType;\r\n};\r\n\r\nexport type LabelProp = Generic.Element.Members<PropLabel, unknown>;\r\n// type LabelWithExpertSlotProp = Generic.Element.Members<PropLabelWithExpertSlot, unknown>;\r\n\r\nfunction getValidationOptions(options: WatchStringOptions): WatchStringOptions {\r\n\treturn {\r\n\t\thooks: {\r\n\t\t\tafterPatch: (value, state, component, key) => {\r\n\t\t\t\tif (typeof options.hooks?.afterPatch === 'function') {\r\n\t\t\t\t\toptions.hooks?.afterPatch(value, state, component, key);\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof value === 'string' && hasEnoughReadableChars(value, 3) === false && containsOnlyNumbers(value) === false) {\r\n\t\t\t\t\ta11yHint(`The heading or label (\"${value}\") is not accessible. A label should consist of at least three readable characters.`);\r\n\t\t\t\t}\r\n\t\t\t\tif (typeof value === 'string' && value.length > 80) {\r\n\t\t\t\t\tuiUxHint(`A heading or label should not be longer than 80 characters.`);\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tbeforePatch: options.hooks?.beforePatch,\r\n\t\t},\r\n\t};\r\n}\r\n\r\nconst LABEL_VALUES = new Set(['string']);\r\nexport const validateLabel = (component: Generic.Element.Component, value?: LabelPropType, options: WatchStringOptions = {}): void => {\r\n\twatchValidator(component, '_label', (value) => typeof value === 'string', LABEL_VALUES, value, getValidationOptions(options));\r\n};\r\n\r\nconst LABEL_WITH_EXPERT_SLOT_VALUES = new Set(['string', 'false']);\r\nexport const validateLabelWithExpertSlot = (\r\n\tcomponent: Generic.Element.Component,\r\n\tvalue?: LabelWithExpertSlotPropType,\r\n\toptions: WatchStringOptions = {}\r\n): void => {\r\n\tif (value === '' || value === 'false') {\r\n\t\tvalue = false; // TODO: remove this workaround in v2\r\n\t}\r\n\twatchValidator(\r\n\t\tcomponent,\r\n\t\t'_label',\r\n\t\t(value) => value === false || typeof value === 'string',\r\n\t\tLABEL_WITH_EXPERT_SLOT_VALUES,\r\n\t\tvalue,\r\n\t\tgetValidationOptions(options)\r\n\t);\r\n};\r\n\r\n// TODO: Validation for labelWithExpertSlot\r\n"],"mappings":";;;sGAYA,MAAMA,EAAiB,sBAKvB,MAAMC,EAAe,QAOrB,SAASC,EAAmBC,G,MAC3B,cAAcA,IAAQ,WAAWC,EAAAD,EAAIE,MAAML,MAAe,MAAAI,SAAA,SAAAA,EAAEE,SAAU,EAAI,CAC3E,C,SAQgBC,EAAuBJ,EAAaK,EAAM,GACzD,OAAON,EAAmBC,IAAQK,CACnC,C,SAOgBC,EAAoBN,GACnC,OAAOF,EAAaS,KAAKP,EAC1B,CAqCA,SAASQ,EAAqBC,G,MAC7B,MAAO,CACNC,MAAO,CACNC,WAAY,CAACC,EAAOC,EAAOC,EAAWC,K,QACrC,WAAWd,EAAAQ,EAAQC,SAAK,MAAAT,SAAA,SAAAA,EAAEU,cAAe,WAAY,EACpDK,EAAAP,EAAQC,SAAK,MAAAM,SAAA,SAAAA,EAAEL,WAAWC,EAAOC,EAAOC,EAAWC,E,CAEpD,UAAWH,IAAU,UAAYR,EAAuBQ,EAAO,KAAO,OAASN,EAAoBM,KAAW,MAAO,CACpHK,EAAS,0BAA0BL,uF,CAEpC,UAAWA,IAAU,UAAYA,EAAMT,OAAS,GAAI,CACnDe,EAAS,8D,GAGXC,aAAalB,EAAAQ,EAAQC,SAAK,MAAAT,SAAA,SAAAA,EAAEkB,aAG/B,CAEA,MAAMC,EAAe,IAAIC,IAAI,CAAC,W,MACjBC,EAAgB,CAACR,EAAsCF,EAAuBH,EAA8B,MACxHc,EAAeT,EAAW,UAAWF,UAAiBA,IAAU,UAAUQ,EAAcR,EAAOJ,EAAqBC,GAAS,EAG9H,MAAMe,EAAgC,IAAIH,IAAI,CAAC,SAAU,U,MAC5CI,EAA8B,CAC1CX,EACAF,EACAH,EAA8B,MAE9B,GAAIG,IAAU,IAAMA,IAAU,QAAS,CACtCA,EAAQ,K,CAETW,EACCT,EACA,UACCF,GAAUA,IAAU,cAAgBA,IAAU,UAC/CY,EACAZ,EACAJ,EAAqBC,GACrB,S"}